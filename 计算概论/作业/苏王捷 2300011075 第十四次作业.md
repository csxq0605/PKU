# Assignment #E: 算法基础

Updated 1419 GMT+8 Dec 12, 2023

2023 fall, Complied by ==苏王捷 工学院==



**说明：**

本周作业涉及到枚举、贪心、bfs、矩阵，建议提前开始作业，如果耗时太⻓，直接找答案看。两个题解，经常更新。所以最好从这个链接下载最新的，https://github.com/GMyhf/2020fall-cs101 。

1）请把每个题目解题思路（可选），源码Python, 或者C++（已经在Codeforces/Openjudge上AC），截图（包含Accepted, 学号），填写到下面作业模版中（推荐使用 typora https://typoraio.cn ，或者用word）。AC 或者没有AC，都请标上每个题目大致花费时间。

2）提交时候先提交pdf文件，再把md或者doc文件上传到右侧“作业评论”。Canvas需要有同学清晰头像、提交文件有pdf、作业评论有md或者doc。

3）如果不能在截止前提交作业，请写明原因。



**编程环境**

==（请改为同学的操作系统、编程环境等）==

操作系统：Windows 11 22H2

Python编程环境：Spyder IDE 5.4.5



## 1. 题目

如果耗时太⻓，直接看解题思路，或者源码



### 02692: 假币问题

brute force, http://cs101.openjudge.cn/practice/02692



思路：对每个硬币的条件讨论，是否满足重币或者轻币条件



##### 代码

```python
# # -*- coding: utf-8 -*-
"""
Created on Tue Dec 12 14:53:41 2023

@author: Lenovo
"""

for _ in range(int(input())):
    cases=[list(input().split())for i in range(3)]
    for coin in "ABCDEFGHIJKL":
        if all((coin in c[0] and c[2]=="up")or(coin in c[1] and c[2]=="down")or(coin not in c[1] and coin not in c[0] and c[2]=="even")for c in cases):
            print(f"{coin} is the counterfeit coin and it is heavy.")
            break
        elif all((coin in c[0] and c[2]=="down")or(coin in c[1] and c[2]=="up")or(coin not in c[0] and coin not in c[1] and c[2]=="even")for c in cases):
            print(f"{coin} is the counterfeit coin and it is light.")
            break

```



代码运行截图 ==（至少包含有"Accepted"）==

![屏幕截图 2023-12-12 162628](C:\Users\Lenovo\Pictures\Screenshots\屏幕截图 2023-12-12 162628.png)



### 18164: 剪绳子

greedy/huffman, http://cs101.openjudge.cn/practice/18164/



思路：heapq结构解决huffman Tree 问题



##### 代码

```python
# # -*- coding: utf-8 -*-
"""
Created on Tue Dec 12 00:42:06 2023

@author: Lenovo
"""

import heapq

n=int(input())
l,ans=list(map(int,input().split())),0
heapq.heapify(l)
while n>=2:
    a=heapq.heappop(l)
    b=heapq.heappop(l)
    ans+=a+b
    n-=1
    heapq.heappush(l,a+b)
print(ans)

```



代码运行截图 ==（AC代码截图，至少包含有"Accepted"）==

![屏幕截图 2023-12-12 162919](C:\Users\Lenovo\Pictures\Screenshots\屏幕截图 2023-12-12 162919.png)



### 01328: Radar Installation

greedy, http://cs101.openjudge.cn/practice/01328/



思路：将点转化为数轴上的线段，即求线段的覆盖区间有几个



##### 代码

```python
# class island:
    def __init__(self,left,right):
        self.left=left
        self.right=right
from math import sqrt
NO,p=1,[]
while True:
    n,d=map(int,input().split())
    if n==0 and d==0:
        break
    l,num,flag,i=[],1,True,0
    while i<n and flag:
        x,y=map(float,input().split())
        if y>d:
            flag=False
        else:    
            left=x-sqrt(d**2-y**2)
            right=x+sqrt(d**2-y**2)
            l.append(island(left,right))
        i+=1
    for j in range(n-i+1):
        input()
    if not flag:
        p.append(f"Case {NO}: -1")
    else:
        l.sort(key=lambda x:x.left)
        left=l[0].left
        right=l[0].right
        for i in range(1,n):
            if l[i].left<=right:
                right=min(right,l[i].right)
            else:
                num+=1
                right=l[i].right
        p.append(f"Case {NO}: {num}")
    NO+=1
for i in p:
    print(i)

```



代码运行截图 ==（AC代码截图，至少包含有"Accepted"）==

![屏幕截图 2023-12-12 162549](C:\Users\Lenovo\Pictures\Screenshots\屏幕截图 2023-12-12 162549.png)



### 19930: 寻宝

bfs, http://cs101.openjudge.cn/practice/19930



思路：加保护圈用heapq存步数，找到最小步数



##### 代码

```python
# # -*- coding: utf-8 -*-
"""
Created on Thu Dec  7 08:56:22 2023

@author: Lenovo
"""

import heapq
def bfs(x,y):
    d=[[-1,0],[1,0],[0,1],[0,-1]]
    queue=[]
    heapq.heappush(queue,[0,x,y])
    check=set()
    check.add((x,y))
    while queue:
        step,x,y=map(int,heapq.heappop(queue))
        if martix[x][y]==1:
            return step
        for i in range(4):
            dx,dy=x+d[i][0],y+d[i][1]
            if martix[dx][dy]!=2 and (dx,dy) not in check:
                heapq.heappush(queue,[step+1,dx,dy])
                check.add((dx,dy))
    return "NO"
            
m,n=map(int,input().split())
martix=[[2]*(n+2)]+[[2]+list(map(int,input().split()))+[2] for i in range(m)]+[[2]*(n+2)]
print(bfs(1,1))

```



代码运行截图 ==（AC代码截图，至少包含有"Accepted"）==

![屏幕截图 2023-12-12 162907](C:\Users\Lenovo\Pictures\Screenshots\屏幕截图 2023-12-12 162907.png)



### 1163B2. Cat Party (Hard Edition)

https://codeforces.com/contest/1163/problem/B2
好题。通过维护双层（三层？）数据结构可以O(n)。

确实好题，而且感觉难度适合作业没有复杂的东西。多维护了几个数就做到O(n)了。



思路：打两个表，一个存数字出现了多少次，一个存次数出现了多少次，判断条件



##### 代码

```python
# # -*- coding: utf-8 -*-
"""
Created on Tue Dec 12 16:17:13 2023

@author: Lenovo
"""

a,b=[0]*100001,[0]*100001
n=int(input())
ans=i=1
for num in map(int,input().split()):
    a[num]+=1
    b[a[num]]+=1
    if a[num]*b[a[num]]==i and i!=n:
        ans=i+1
    elif a[num]*b[a[num]]==i-1:
        ans=i
    i+=1
print(ans)

```



代码运行截图 ==（AC代码截图，至少包含有"Accepted"）==

![屏幕截图 2023-12-12 163533](C:\Users\Lenovo\Pictures\Screenshots\屏幕截图 2023-12-12 163533.png)





### 02811: 熄灯问题

brute force, http://cs101.openjudge.cn/practice/02811



思路：枚举对第一列的操作，每个下一列即为上一列变化后的结果，才能使上一列灯完全熄灭；最找到能使第五列灯全熄灭的方案



##### 代码

```python
# # -*- coding: utf-8 -*-
"""
Created on Tue Dec 12 15:53:03 2023

@author: Lenovo
"""

from itertools import product
import copy
martix=[[0]*8]+[[0]+list(map(int,input().split()))+[0] for i in range(5)]+[[0]*8]
for cases in product([0,1],repeat=6):
    martixcopy=copy.deepcopy(martix)
    ans=[list(cases)]
    for i in range(1,6):
        for j in range(1,7):
            if ans[i-1][j-1]:
                martixcopy[i][j]=(martixcopy[i][j]+1)%2
                martixcopy[i][j-1]=(martixcopy[i][j-1]+1)%2
                martixcopy[i][j+1]=(martixcopy[i][j+1]+1)%2
                martixcopy[i+1][j]=(martixcopy[i+1][j]+1)%2
        ans.append(martixcopy[i][1:7])
    if martixcopy[5][1:7]==[0,0,0,0,0,0]:
        for line in ans[0:-1]:
            print(*line)

```



代码运行截图 ==（AC代码截图，至少包含有"Accepted"）==

![屏幕截图 2023-12-12 162804](C:\Users\Lenovo\Pictures\Screenshots\屏幕截图 2023-12-12 162804.png)



### 02802: 小游戏

dfs, bfs, http://cs101.openjudge.cn/practice/02802/ 



思路：加保护圈用heapq存线段数，找到最小的线段数



##### 代码

```python
# # -*- coding: utf-8 -*-
"""
Created on Wed Dec  6 10:35:07 2023

@author: Lenovo
"""

import heapq
num1=1
while True:
    w,h=map(int,input().split())
    if w==0 and h==0:
        break
    print(f"Board #{num1}:")
    martix=[[" "]*(w+2)]+[[" "]+list(input())+[" "] for _ in range(h)]+[[" "]*(w+2)]
    dir=[(0,1),(0,-1),(1,0),(-1,0)]
    num2=1
    while True:
        x1,y1,x2,y2=map(int,input().split())
        if x1==0 and x2==0 and y1==0 and y2==0:
            break
        queue,flag=[],False
        vis=set()
        heapq.heappush(queue,(0,x1,y1,-1))
        martix[y2][x2]=" "
        vis.add((-1,x1,y1))
        while queue:
            step,x,y,dirs=heapq.heappop(queue)
            if x==x2 and y==y2:
                flag=True
                break
            for i,(dx,dy) in enumerate(dir):
                px,py=x+dx,y+dy
                if 0<=px<=w+1 and 0<=py<=h+1 and (i,px,py) not in vis and martix[py][px]!="X":
                    vis.add((i,px,py))
                    heapq.heappush(queue,(step+(dirs!=i),px,py,i))
        if flag:
            print(f"Pair {num2}: {step} segments.")
        else:
            print(f"Pair {num2}: impossible.")
        martix[y2][x2]="X"
        num2+=1
    print()
    num1+=1

```



代码运行截图 ==（至少包含有"Accepted"）==

![屏幕截图 2023-12-12 162652](C:\Users\Lenovo\Pictures\Screenshots\屏幕截图 2023-12-12 162652.png)



## 2. 学习总结和收获

==如果作业题目简单，有否额外练习题目，比如：OJ“每日选做”中每天推出的2题目、CF、LeetCode、洛谷等网站题目。==

这期作业大量使用heapq堆结构就能迅速解决，其实所有求最短、最长的问题都能用heapq实现，在图搜索中搭配bfs尤其好用。

这次卡的最久的竟然是两道brute Force。。。优化想了挺久，感觉不如少点难优化的brute froce问题多来点算法   :）



